/**
 * Self-Improvement Loop for Skynet
 *
 * Comprehensive metrics collection, experiment framework, and PM agent
 * that generates improvement quests based on empirical data.
 */
import { EfficiencyAnalyzer } from "./efficiency-analyzer.js";
import { EfficiencyTracker } from "./efficiency-tracker.js";
import { raidLogger } from "./logger.js";
import { MetricsTracker } from "./metrics.js";
import type {
	AgentType,
	CompletionMetrics,
	EfficiencyComparison,
	EfficiencyOutcome,
	ExperimentResult,
	LoadoutModelChoices,
	ParallelismLevel,
	QuestMetrics,
} from "./types.js";

/**
 * Experiment configuration for A/B testing
 */
export interface ExperimentConfig {
	id: string;
	hypothesis: string;
	variants: Array<{
		name: string;
		description: string;
		parallelismLevel: ParallelismLevel;
		modelChoices: LoadoutModelChoices;
		weight: number; // 0-1, probability of assignment
	}>;
	targetSampleSize: number;
	maxDurationDays: number;
	successMetrics: string[];
}

/**
 * Improvement quest generated by the PM agent
 */
export interface ImprovementQuest {
	id: string;
	title: string;
	description: string;
	priority: "low" | "medium" | "high" | "critical";
	category: "performance" | "quality" | "efficiency" | "reliability" | "usability";
	dataSource: "metrics" | "experiments" | "patterns" | "manual";
	evidence: string[];
	estimatedImpact: number; // 0-100 score
	estimatedEffort: "low" | "medium" | "high";
	createdAt: Date;
	experimentId?: string; // If this quest is from an experiment
}

/**
 * PM Agent that analyzes data and generates improvement quests
 */
export class PMAgent {
	private metricsTracker: MetricsTracker;
	private efficiencyAnalyzer: EfficiencyAnalyzer;

	constructor() {
		this.metricsTracker = new MetricsTracker();
		this.efficiencyAnalyzer = new EfficiencyAnalyzer();
	}

	/**
	 * Analyze metrics and generate improvement quests
	 */
	generateImprovementQuests(
		questMetrics: QuestMetrics[],
		efficiencyOutcomes: EfficiencyOutcome[],
		experimentResults: ExperimentResult[],
	): ImprovementQuest[] {
		const quests: ImprovementQuest[] = [];

		// Performance-based quests
		quests.push(...this.analyzePerformanceMetrics(questMetrics));

		// Efficiency-based quests
		quests.push(...this.analyzeEfficiencyData(efficiencyOutcomes));

		// Experiment-based quests
		quests.push(...this.analyzeExperimentResults(experimentResults));

		// Pattern-based quests
		quests.push(...this.analyzeFailurePatterns(questMetrics, experimentResults));

		// Quality-based quests
		quests.push(...this.analyzeQualityMetrics(questMetrics));

		// Sort by priority and impact
		return quests.sort((a, b) => {
			const priorityScore = { critical: 4, high: 3, medium: 2, low: 1 };
			const aPriority = priorityScore[a.priority];
			const bPriority = priorityScore[b.priority];

			if (aPriority !== bPriority) {
				return bPriority - aPriority;
			}

			return b.estimatedImpact - a.estimatedImpact;
		});
	}

	private analyzePerformanceMetrics(questMetrics: QuestMetrics[]): ImprovementQuest[] {
		const quests: ImprovementQuest[] = [];

		if (questMetrics.length === 0) return quests;

		const analytics = MetricsTracker.calculateAnalytics(questMetrics);

		// Slow completion times
		if (analytics.avgDurationMs > 30 * 60 * 1000) {
			// 30 minutes
			quests.push({
				id: `perf-slow-completion-${Date.now()}`,
				title: "Optimize quest completion speed",
				description: `Average quest completion time is ${Math.round(analytics.avgDurationMs / 60000)} minutes. Investigate bottlenecks and optimize agent efficiency.`,
				priority: "high",
				category: "performance",
				dataSource: "metrics",
				evidence: [
					`Average duration: ${Math.round(analytics.avgDurationMs / 60000)} minutes`,
					`Total quests analyzed: ${analytics.totalQuests}`,
					`Success rate: ${analytics.successRate.toFixed(1)}%`,
				],
				estimatedImpact: 85,
				estimatedEffort: "high",
				createdAt: new Date(),
			});
		}

		// High token usage
		if (analytics.avgTokensPerCompletion > 100000) {
			quests.push({
				id: `perf-high-tokens-${Date.now()}`,
				title: "Reduce token consumption per quest",
				description: `Average token usage is ${Math.round(analytics.avgTokensPerCompletion)} per completion. Optimize prompts and reduce redundant processing.`,
				priority: "medium",
				category: "efficiency",
				dataSource: "metrics",
				evidence: [
					`Average tokens: ${Math.round(analytics.avgTokensPerCompletion)}`,
					`Most efficient agent: ${analytics.mostEfficientAgentType || "none"}`,
				],
				estimatedImpact: 70,
				estimatedEffort: "medium",
				createdAt: new Date(),
			});
		}

		// Low success rate
		if (analytics.successRate < 80) {
			quests.push({
				id: `quality-low-success-${Date.now()}`,
				title: "Improve quest success rate",
				description: `Quest success rate is only ${analytics.successRate.toFixed(1)}%. Investigate failure modes and improve reliability.`,
				priority: "critical",
				category: "quality",
				dataSource: "metrics",
				evidence: [
					`Success rate: ${analytics.successRate.toFixed(1)}%`,
					`Failed quests: ${analytics.totalQuests - Math.round((analytics.totalQuests * analytics.successRate) / 100)}`,
				],
				estimatedImpact: 95,
				estimatedEffort: "high",
				createdAt: new Date(),
			});
		}

		// Inefficient agent usage
		if (analytics.avgAgentsSpawned > 5) {
			quests.push({
				id: `efficiency-agent-spawning-${Date.now()}`,
				title: "Optimize agent spawning strategy",
				description: `Average of ${analytics.avgAgentsSpawned.toFixed(1)} agents per quest suggests over-spawning. Optimize agent allocation.`,
				priority: "medium",
				category: "efficiency",
				dataSource: "metrics",
				evidence: [
					`Average agents spawned: ${analytics.avgAgentsSpawned.toFixed(1)}`,
					`Token distribution by agent type available`,
				],
				estimatedImpact: 60,
				estimatedEffort: "medium",
				createdAt: new Date(),
			});
		}

		return quests;
	}

	private analyzeEfficiencyData(efficiencyOutcomes: EfficiencyOutcome[]): ImprovementQuest[] {
		const quests: ImprovementQuest[] = [];

		if (efficiencyOutcomes.length < 10) return quests; // Need sufficient data

		const comparison = this.efficiencyAnalyzer.analyzeEfficiency(efficiencyOutcomes);

		// High rework rates
		if (comparison.linearMode.avgReworkRate > 2 || comparison.swarmMode.avgReworkRate > 2) {
			const worseMode = comparison.linearMode.avgReworkRate > comparison.swarmMode.avgReworkRate ? "linear" : "swarm";
			const reworkRate =
				worseMode === "linear" ? comparison.linearMode.avgReworkRate : comparison.swarmMode.avgReworkRate;

			quests.push({
				id: `efficiency-high-rework-${Date.now()}`,
				title: "Reduce rework cycles in quest execution",
				description: `${worseMode} mode shows high rework rate of ${reworkRate.toFixed(2)} attempts per quest. Investigate quality issues.`,
				priority: "high",
				category: "efficiency",
				dataSource: "experiments",
				evidence: [
					`${worseMode} mode rework rate: ${reworkRate.toFixed(2)}`,
					`Statistical significance: ${comparison.significance.reworkRatePValue < 0.05}`,
				],
				estimatedImpact: 80,
				estimatedEffort: "high",
				createdAt: new Date(),
			});
		}

		// User intervention required too often
		const highInterventions = Math.max(
			comparison.linearMode.avgUserInterventions,
			comparison.swarmMode.avgUserInterventions,
		);
		if (highInterventions > 1) {
			quests.push({
				id: `automation-user-interventions-${Date.now()}`,
				title: "Reduce required user interventions",
				description: `Quests require ${highInterventions.toFixed(1)} user interventions on average. Improve autonomous decision-making.`,
				priority: "high",
				category: "usability",
				dataSource: "experiments",
				evidence: [
					`Linear mode interventions: ${comparison.linearMode.avgUserInterventions.toFixed(1)}`,
					`Swarm mode interventions: ${comparison.swarmMode.avgUserInterventions.toFixed(1)}`,
				],
				estimatedImpact: 85,
				estimatedEffort: "high",
				createdAt: new Date(),
			});
		}

		// Parallelism not paying off
		if (comparison.significance.overallSignificant && comparison.model.parallelismBonus < 0.1) {
			quests.push({
				id: `parallelism-optimization-${Date.now()}`,
				title: "Optimize parallel execution strategy",
				description:
					"Swarm mode is not providing expected parallelism benefits. Review coordination overhead and task decomposition.",
				priority: "medium",
				category: "performance",
				dataSource: "experiments",
				evidence: [
					`Parallelism bonus: ${(comparison.model.parallelismBonus * 100).toFixed(1)}%`,
					`Statistically significant: ${comparison.significance.overallSignificant}`,
				],
				estimatedImpact: 70,
				estimatedEffort: "high",
				createdAt: new Date(),
			});
		}

		return quests;
	}

	private analyzeExperimentResults(experimentResults: ExperimentResult[]): ImprovementQuest[] {
		const quests: ImprovementQuest[] = [];

		if (experimentResults.length === 0) return quests;

		const recentExperiments = experimentResults.filter(
			(exp) => Date.now() - exp.duration < 30 * 24 * 60 * 60 * 1000, // Last 30 days
		);

		const failureRate = recentExperiments.filter((exp) => !exp.success).length / recentExperiments.length;

		// High experiment failure rate
		if (failureRate > 0.3 && recentExperiments.length > 5) {
			quests.push({
				id: `experiments-high-failure-${Date.now()}`,
				title: "Improve experiment framework reliability",
				description: `${(failureRate * 100).toFixed(1)}% of recent experiments failed. Review experiment design and execution.`,
				priority: "medium",
				category: "reliability",
				dataSource: "experiments",
				evidence: [
					`Recent failure rate: ${(failureRate * 100).toFixed(1)}%`,
					`Recent experiments: ${recentExperiments.length}`,
				],
				estimatedImpact: 60,
				estimatedEffort: "medium",
				createdAt: new Date(),
			});
		}

		return quests;
	}

	private analyzeFailurePatterns(
		questMetrics: QuestMetrics[],
		_experimentResults: ExperimentResult[],
	): ImprovementQuest[] {
		const quests: ImprovementQuest[] = [];

		// Collect error patterns from failed quests
		const failedQuests = questMetrics.filter((q) => !q.success);
		const errorPatterns = new Map<string, number>();

		for (const quest of failedQuests) {
			if (quest.error) {
				const normalizedError = this.normalizeError(quest.error);
				errorPatterns.set(normalizedError, (errorPatterns.get(normalizedError) || 0) + 1);
			}
		}

		// Find recurring error patterns
		for (const [pattern, count] of errorPatterns) {
			if (count >= 3 && count / failedQuests.length > 0.2) {
				// At least 3 occurrences and 20% of failures
				quests.push({
					id: `pattern-error-${Date.now()}-${pattern.slice(0, 20)}`,
					title: "Fix recurring error pattern",
					description: `Error pattern "${pattern}" occurs in ${count} quests (${((count / failedQuests.length) * 100).toFixed(1)}% of failures).`,
					priority: count >= 5 ? "high" : "medium",
					category: "reliability",
					dataSource: "patterns",
					evidence: [
						`Error pattern: ${pattern}`,
						`Occurrences: ${count}`,
						`Percentage of failures: ${((count / failedQuests.length) * 100).toFixed(1)}%`,
					],
					estimatedImpact: Math.min(90, count * 15),
					estimatedEffort: "medium",
					createdAt: new Date(),
				});
			}
		}

		return quests;
	}

	private analyzeQualityMetrics(questMetrics: QuestMetrics[]): ImprovementQuest[] {
		const quests: ImprovementQuest[] = [];

		if (questMetrics.length === 0) return quests;

		// Analyze agent type performance
		const agentTypeStats = new Map<
			AgentType,
			{ total: number; successful: number; avgTokens: number; avgDuration: number }
		>();

		for (const quest of questMetrics) {
			for (const agentType of quest.agentTypes) {
				const stats = agentTypeStats.get(agentType) || { total: 0, successful: 0, avgTokens: 0, avgDuration: 0 };
				stats.total++;
				if (quest.success) stats.successful++;
				stats.avgTokens += quest.totalTokens / quest.agentTypes.length; // Distribute tokens evenly
				stats.avgDuration += quest.durationMs;
				agentTypeStats.set(agentType, stats);
			}
		}

		// Find underperforming agent types
		for (const [agentType, stats] of agentTypeStats) {
			if (stats.total >= 5) {
				// Need sufficient sample size
				const successRate = stats.successful / stats.total;
				const avgTokens = stats.avgTokens / stats.total;
				const avgDuration = stats.avgDuration / stats.total;

				if (successRate < 0.7) {
					// Less than 70% success
					quests.push({
						id: `quality-agent-${agentType}-${Date.now()}`,
						title: `Improve ${agentType} agent reliability`,
						description: `${agentType} agent has ${(successRate * 100).toFixed(1)}% success rate. Investigate and improve agent capabilities.`,
						priority: successRate < 0.5 ? "high" : "medium",
						category: "quality",
						dataSource: "metrics",
						evidence: [
							`Success rate: ${(successRate * 100).toFixed(1)}%`,
							`Sample size: ${stats.total} quests`,
							`Average tokens: ${Math.round(avgTokens)}`,
							`Average duration: ${Math.round(avgDuration / 60000)} minutes`,
						],
						estimatedImpact: Math.round(85 * (1 - successRate)),
						estimatedEffort: "medium",
						createdAt: new Date(),
					});
				}
			}
		}

		return quests;
	}

	private normalizeError(error: string): string {
		return error
			.replace(/:\d+:\d+/g, "") // Remove line numbers
			.replace(/\/[\w\-./]+/g, "FILE") // Replace file paths
			.replace(/'[^']+'/g, "'X'") // Replace quoted strings
			.replace(/\d+/g, "N") // Replace numbers
			.trim()
			.toLowerCase()
			.slice(0, 100); // Limit length
	}
}

export class SelfImprovementAgent {
	private metrics: CompletionMetrics[] = [];
	private experiments: ExperimentResult[] = [];
	private efficiencyOutcomes: EfficiencyOutcome[] = [];
	private questMetrics: QuestMetrics[] = [];
	private activeExperiments: Map<string, ExperimentConfig> = new Map();
	private pmAgent: PMAgent;

	constructor() {
		this.pmAgent = new PMAgent();
	}

	/**
	 * Collect metrics from a completed raid/task
	 */
	collectMetrics(metrics: CompletionMetrics): void {
		this.metrics.push(metrics);
		this.analyzeMetrics();
	}

	/**
	 * Collect quest metrics for detailed analysis
	 */
	collectQuestMetrics(metrics: QuestMetrics): void {
		this.questMetrics.push(metrics);
	}

	/**
	 * Collect efficiency outcome for A/B analysis
	 */
	collectEfficiencyOutcome(outcome: EfficiencyOutcome): void {
		this.efficiencyOutcomes.push(outcome);
	}

	/**
	 * Start a new A/B experiment
	 */
	startExperiment(config: ExperimentConfig): void {
		this.activeExperiments.set(config.id, config);

		raidLogger.info(
			{
				experimentId: config.id,
				hypothesis: config.hypothesis,
				variants: config.variants.length,
			},
			"Started A/B experiment",
		);
	}

	/**
	 * Assign a variant to a quest for A/B testing
	 */
	assignExperimentVariant(
		experimentId: string,
	): { variantName: string; config: ExperimentConfig["variants"][0] } | null {
		const experiment = this.activeExperiments.get(experimentId);
		if (!experiment) return null;

		// Weighted random selection
		const rand = Math.random();
		let cumulativeWeight = 0;

		for (const variant of experiment.variants) {
			cumulativeWeight += variant.weight;
			if (rand <= cumulativeWeight) {
				return {
					variantName: variant.name,
					config: variant,
				};
			}
		}

		// Fallback to first variant
		return {
			variantName: experiment.variants[0].name,
			config: experiment.variants[0],
		};
	}

	/**
	 * Run an experiment to test a potential improvement
	 */
	async runExperiment(hypothesis: string, experimentFn: () => Promise<unknown>): Promise<ExperimentResult> {
		const startTime = Date.now();
		let result: ExperimentResult = {
			hypothesis,
			success: false,
			duration: 0,
			details: null,
		};

		try {
			const output = await experimentFn();
			result = {
				hypothesis,
				success: true,
				duration: Date.now() - startTime,
				details: output,
			};
		} catch (error) {
			result.duration = Date.now() - startTime;
			result.details = error;
		}

		this.experiments.push(result);
		this.analyzeExperiments();

		raidLogger.info(
			{
				event: "experiment",
				hypothesis,
				success: result.success,
			},
			"Experiment completed",
		);

		return result;
	}

	/**
	 * Generate improvement quests using the PM agent
	 */
	generateImprovementQuests(): ImprovementQuest[] {
		return this.pmAgent.generateImprovementQuests(this.questMetrics, this.efficiencyOutcomes, this.experiments);
	}

	/**
	 * Get experiment results for analysis
	 */
	getExperiments(): ExperimentResult[] {
		return [...this.experiments];
	}

	/**
	 * Get efficiency outcomes for analysis
	 */
	getEfficiencyOutcomes(): EfficiencyOutcome[] {
		return [...this.efficiencyOutcomes];
	}

	/**
	 * Get quest metrics for analysis
	 */
	getQuestMetrics(): QuestMetrics[] {
		return [...this.questMetrics];
	}

	/**
	 * Get active experiments
	 */
	getActiveExperiments(): Map<string, ExperimentConfig> {
		return new Map(this.activeExperiments);
	}

	/**
	 * Stop an active experiment
	 */
	stopExperiment(experimentId: string): boolean {
		return this.activeExperiments.delete(experimentId);
	}

	/**
	 * Get experiment status and results
	 */
	getExperimentStatus(experimentId: string): {
		config: ExperimentConfig | null;
		resultsCount: number;
		completionRate: number;
		preliminaryResults?: EfficiencyComparison;
	} {
		const config = this.activeExperiments.get(experimentId) || null;

		const experimentOutcomes = this.efficiencyOutcomes.filter((outcome) => outcome.experimentId === experimentId);
		const resultsCount = experimentOutcomes.length;
		const completionRate = config ? resultsCount / config.targetSampleSize : 0;

		let preliminaryResults: EfficiencyComparison | undefined;
		if (resultsCount >= 10) {
			// Minimum for preliminary analysis
			const analyzer = new EfficiencyAnalyzer();
			preliminaryResults = analyzer.analyzeEfficiency(experimentOutcomes, `Experiment ${experimentId}`);
		}

		return {
			config,
			resultsCount,
			completionRate,
			preliminaryResults,
		};
	}

	/**
	 * Generate a comprehensive metrics report
	 */
	generateMetricsReport(): {
		summary: {
			totalQuestMetrics: number;
			totalExperiments: number;
			totalEfficiencyOutcomes: number;
			activeExperiments: number;
		};
		performance: {
			avgCompletionTime: number;
			successRate: number;
			avgTokensPerQuest: number;
			mostEfficientAgent: AgentType | null;
		};
		trends: {
			improvingMetrics: string[];
			deterioratingMetrics: string[];
		};
		recommendations: ImprovementQuest[];
	} {
		const summary = {
			totalQuestMetrics: this.questMetrics.length,
			totalExperiments: this.experiments.length,
			totalEfficiencyOutcomes: this.efficiencyOutcomes.length,
			activeExperiments: this.activeExperiments.size,
		};

		// Calculate performance metrics
		const recentMetrics = this.questMetrics.slice(-50); // Last 50 quests
		const analytics = MetricsTracker.calculateAnalytics(recentMetrics);

		const performance = {
			avgCompletionTime: this.calculateAverageCompletionTime(),
			successRate: analytics.successRate,
			avgTokensPerQuest: analytics.avgTokensPerCompletion,
			mostEfficientAgent: analytics.mostEfficientAgentType,
		};

		// Analyze trends
		const trends = this.analyzeTrends();

		// Get improvement recommendations
		const recommendations = this.generateImprovementQuests();

		return {
			summary,
			performance,
			trends,
			recommendations,
		};
	}

	/**
	 * Calculate average raid/task completion time
	 */
	private calculateAverageCompletionTime(): number {
		if (this.questMetrics.length === 0 && this.metrics.length === 0) return 0;

		if (this.questMetrics.length > 0) {
			const totalTime = this.questMetrics.reduce((sum, metric) => sum + metric.durationMs, 0);
			return totalTime / this.questMetrics.length;
		}

		const totalTime = this.metrics.reduce((sum, metric) => sum + metric.completionTime, 0);
		return totalTime / this.metrics.length;
	}

	/**
	 * Analyze trends in metrics over time
	 */
	private analyzeTrends(): {
		improvingMetrics: string[];
		deterioratingMetrics: string[];
	} {
		const improvingMetrics: string[] = [];
		const deterioratingMetrics: string[] = [];

		if (this.questMetrics.length < 20) {
			return { improvingMetrics, deterioratingMetrics };
		}

		const halfway = Math.floor(this.questMetrics.length / 2);
		const earlierMetrics = this.questMetrics.slice(0, halfway);
		const laterMetrics = this.questMetrics.slice(halfway);

		const earlierAnalytics = MetricsTracker.calculateAnalytics(earlierMetrics);
		const laterAnalytics = MetricsTracker.calculateAnalytics(laterMetrics);

		// Check success rate trend
		if (laterAnalytics.successRate > earlierAnalytics.successRate + 5) {
			improvingMetrics.push("success rate");
		} else if (laterAnalytics.successRate < earlierAnalytics.successRate - 5) {
			deterioratingMetrics.push("success rate");
		}

		// Check completion time trend
		if (laterAnalytics.avgDurationMs < earlierAnalytics.avgDurationMs * 0.9) {
			improvingMetrics.push("completion time");
		} else if (laterAnalytics.avgDurationMs > earlierAnalytics.avgDurationMs * 1.1) {
			deterioratingMetrics.push("completion time");
		}

		// Check token efficiency trend
		if (laterAnalytics.avgTokensPerCompletion < earlierAnalytics.avgTokensPerCompletion * 0.9) {
			improvingMetrics.push("token efficiency");
		} else if (laterAnalytics.avgTokensPerCompletion > earlierAnalytics.avgTokensPerCompletion * 1.1) {
			deterioratingMetrics.push("token efficiency");
		}

		return { improvingMetrics, deterioratingMetrics };
	}

	/**
	 * Analyze collected metrics
	 */
	private analyzeMetrics(): void {
		const recentMetrics = this.metrics.slice(-10); // Last 10 metrics
		raidLogger.debug(
			{
				event: "metrics_analysis",
				metricCount: recentMetrics.length,
			},
			"Analyzing recent performance metrics",
		);
	}

	/**
	 * Analyze experiments for patterns
	 */
	private analyzeExperiments(): void {
		const recentExperiments = this.experiments.slice(-10); // Last 10 experiments
		raidLogger.debug(
			{
				event: "experiment_analysis",
				experimentCount: recentExperiments.length,
			},
			"Analyzing recent experiments",
		);
	}

	/**
	 * Create an efficiency tracker for a quest
	 */
	createEfficiencyTracker(
		questId: string,
		raidId: string,
		objective: string,
		parallelismLevel: ParallelismLevel,
		modelChoices: LoadoutModelChoices,
		experimentId?: string,
		variantName?: string,
	): EfficiencyTracker {
		return new EfficiencyTracker(questId, raidId, objective, parallelismLevel, modelChoices, experimentId, variantName);
	}
}

// Singleton instance for global access
export const selfImprovementAgent = new SelfImprovementAgent();
