# Research: Review performance-critical paths in src/**/*.ts and src/**/*.tsx

_Generated by automated PM on 2026-01-20T00:10:09.655Z_

## Summary

### Key Findings

- React Compiler (React 19.2+) now provides automatic memoization, reducing manual useMemo/React.memo overhead by up to 65% in build times, but requires 4-8 week pilot testing on 2-3 critical pages
- Request waterfalls are the highest-impact bottleneck - a 600ms waterfall eliminates all micro-optimization benefits, making architectural analysis paramount before component-level optimization
- Bundle size directly impacts FCP and LCP metrics - features not visible on initial load should use route-based code splitting with React.lazy() and Suspense to avoid blocking critical rendering paths
- Server Components reduce client bundle size by rendering on server without shipping JavaScript, achieving zero client-side bundle impact for read-heavy, non-interactive content
- Poor render performance causes 30-60% increases in scripting time during critical paths - profiling with React DevTools Profiler and Chrome Performance tab should target components exceeding 16ms (60 FPS budget)
- Context API changes trigger re-renders across entire consumer tree - frequently changing state (auth, filters, inputs) benefits from state management alternatives or context splitting
- TypeScript compiler diagnostics and 'generate trace' command identify type-checking bottlenecks, with complex types significantly impacting compilation performance
- Third-party script management can reduce performance impact by 60-80% while maintaining 90%+ functionality when strategically optimized
- React Performance Tracks (React 19.2+) show React-specific events in Chrome DevTools timeline alongside network requests for holistic performance analysis
- Virtualization (windowing) is critical for lists with hundreds/thousands of items, rendering only visible subset to dramatically reduce re-render times

### Recommendations

- Profile first using React DevTools Profiler to identify components exceeding 16ms render time, then use Chrome Performance tab to analyze request waterfalls and bundle loading patterns
- Implement route-based code splitting immediately for any features not visible on initial page load using React.lazy() and Suspense
- Audit Context API usage - split contexts with frequently changing values from stable ones, or migrate high-frequency state to alternatives like Zustand or Jotai
- Enable TypeScript extended diagnostics (--extendedDiagnostics flag) and use 'generate trace' to identify type-checking bottlenecks in large codebases
- Pilot React Compiler on 2-3 performance-critical pages to evaluate automatic memoization benefits versus current manual optimization patterns
- Evaluate Server Components for read-heavy pages that don't require interactivity - prioritize pages with large data fetching or static content rendering
- Implement virtualization using react-window or @tanstack/react-virtual for any lists rendering 50+ items simultaneously
- Analyze third-party scripts with Chrome DevTools Coverage tab - defer, async, or remove scripts contributing to main thread blocking
- Set up performance budgets targeting 16ms per component render and monitor with automated profiling in CI/CD pipeline
- Replace runtime CSS-in-JS with build-time solutions (CSS Modules, Tailwind) to eliminate client-side style calculation overhead

### Sources

- https://vercel.com/blog/introducing-react-best-practices
- https://johal.in/typescript-best-practices-for-large-scale-web-applications-in-2026/
- https://dev.to/alex_bobes/react-performance-optimization-15-best-practices-for-2025-17l9
- https://www.growin.com/blog/react-performance-optimization-2025/
- https://www.patterns.dev/react/react-2026/
- https://medium.com/@expertappdevs/react-js-2026-performance-secure-architecture-84f78ad650ab
- https://stevekinney.com/courses/react-typescript/typescript-performance-large-codebases
- https://www.debugbear.com/blog/measuring-react-app-performance
- https://dev.to/alisamir/a-practical-guide-to-profiling-optimizing-react-applications-for-peak-performance-273i
- https://gitnation.com/contents/typescript-performance-going-beyond-the-surface
- https://fygs.dev/en/blog/advanced-react-performance-patterns

## Generated Tasks

### Profile all routes and components using React DevTools Profiler to identify renders exceeding 16ms

**Rationale:** Components exceeding 16ms disrupt 60 FPS frame budget causing visible performance degradation. This establishes baseline metrics for targeted optimization.
**Priority:** 900
**Tags:** performance, profiling, react, critical-path

### Analyze and optimize request waterfalls using Chrome DevTools Performance tab

**Rationale:** Request waterfalls are the highest-impact bottleneck - a 600ms waterfall eliminates all component-level optimization benefits. Must address before micro-optimizations.
**Priority:** 950
**Tags:** performance, network, waterfall, critical

### Implement route-based code splitting for non-critical features using React.lazy() and Suspense

**Rationale:** Bundle size directly impacts FCP and LCP Core Web Vitals. Features not visible on initial load should not block rendering.
**Priority:** 850
**Tags:** performance, code-splitting, bundle-size, react

### Audit and split Context API implementations with frequently changing values

**Rationale:** Context changes trigger re-renders across entire consumer tree. Frequently changing state (auth, filters) causes excessive re-renders reducing performance by 30-60%.
**Priority:** 800
**Tags:** performance, react, context, state-management

### Run TypeScript compiler diagnostics (--extendedDiagnostics, generate trace) to identify type-checking bottlenecks

**Rationale:** Complex types significantly impact compilation performance in large codebases. Modern tooling can reduce build times by 65%.
**Priority:** 750
**Tags:** typescript, performance, build-time, profiling

### Evaluate React Compiler pilot on 2-3 critical pages for automatic memoization

**Rationale:** React Compiler reduces manual useMemo/React.memo overhead and performance regressions. Requires 4-8 week pilot to validate benefits.
**Priority:** 700
**Tags:** react, compiler, optimization, memoization

### Implement virtualization for lists rendering 50+ items using react-window or @tanstack/react-virtual

**Rationale:** Windowing technique renders only visible subset, dramatically reducing re-render times for large lists by hundreds of milliseconds.
**Priority:** 800
**Tags:** performance, virtualization, react, lists

### Audit third-party scripts with Coverage tab and optimize loading strategy

**Rationale:** Strategic third-party script management reduces performance impact by 60-80% while maintaining 90%+ functionality.
**Priority:** 750
**Tags:** performance, third-party, scripts, optimization
